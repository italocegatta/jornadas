[["index.html", "R para análise de dados Apresentação Requisitos", " R para análise de dados Apresentação Instrutor: Ítalo Cegatta Blog pessoal: https://italocegatta.github.io Requisitos Material online Software R Software RStudio Pacotes install.packages(c(\"tidyverse\", \"readxl\", \"gapminder\")) Bases de dados Parte 1 - Introdução à linguagem R e Processamento Básico de dados Linguagem R e RStudio Manipulação de dados Parte 2 - Visualização de dados e estatística experimental Processamento e análise gráfica de dados "],["sobre-o-r.html", "Sobre o R Download do R e RStudio", " Sobre o R Se dedicar para aprender uma nova linguagem de programação não é uma tarefa fácil. Principalmente para quem não tem um background de lógica de programação. O R é um software open-source mantido por um grupo de voluntários de vários países, o R-core team. No site oficial do projeto a primeira descrição sobre ele é a seguinte: O R é uma linguagem e ambiente para computação estatística e gráficos. Esse grupo mantem o sistema base que possibilita a interação com a linguagem R para computação numérica, manipulação de dados, gráficos e uma variedade de outras tarefas. No R, tudo o que acontece é o resultado de uma função. Eu, você e tantos outros usuários podemos desenvolver funções para facilitar a nossa vida, posteriormente organizá-las em pacotes (ou packages) e depois disponibilizar para todo o mundo. O projeto do R teve início com Ross Ihaka e Robert Gentleman nos anos 90 a partir de uma implementação da linguagem S, que foi desenvolvida anos antes por um grupo de pesquisadores liderados por John Chambers no Bell Laboratories. Desde então, o R tem crescido em um ritmo absurdo e pode ser considerado o principal software livre para programação estatística e um dos mais usados no mundo. Sobre as potencialidades do R, no contexto de análise de dados, não há restrições. Em comparação com outras linguagem e softwares podemos ter diferença entre velocidade de processamento, suporte e disponibilidade de bibliotecas específicas, mas há um jargão antigo na comunidade R diz: pergunta certa sobre uma tarefa no R não é se podemos fazer, mas sim como podemos fazer. Download do R e RStudio O download do software R pode ser feito no site do CRAN. Após a instalação você já está apto para iniciar sua análise. Para trabalharmos em um ambiente com maiores funcionalidade, podemos optar por utilizar um ambiente de desenvolvimento integrado ao R. O RStudio é um dos mais utilizados e possui diversas funcionalidades que facilitam nossa vida durante uma análise. Faça o download do RStudio nesse link. Note que é preciso instlar o R antes, para conseguir instalar o Rstudio normalmente. "],["manipulação-de-dados.html", "Manipulação de dados Warm-Up Sobre o Tidyverse", " Manipulação de dados Warm-Up Conhecendo os dados Vamos começar importando os dados do arquivo input/jpf_ifc_ms.xlsx. Para indicar que o arquivo está dentro de uma pasta, é preciso utilizar a barra /, library(tidyverse) ## ── Attaching core tidyverse packages ── ## ✔ dplyr 1.1.4 ✔ readr 2.1.4 ## ✔ forcats 1.0.0 ✔ stringr 1.5.1 ## ✔ ggplot2 3.4.4 ✔ tibble 3.2.1 ## ✔ lubridate 1.9.3 ✔ tidyr 1.3.0 ## ✔ purrr 1.0.2 ## ── Conflicts ────────────────────────── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors library(readxl) tab_ifc &lt;- read_excel(&quot;input/jpf_ifc_ms.xlsx&quot;) tab_ifc ## # A tibble: 70,916 × 8 ## matgen indice_sitio imatcc dap altura altura_dom area_basal ncovas_viva ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ARA6084 25.3 17.5 10.7 12.8 13.8 8.45 900 ## 2 ARA6084 24.8 13.7 9.99 12.1 13.2 6.98 850 ## 3 VT01 28.2 29.5 11.7 17.0 18.6 11.9 1100 ## 4 VT01 27.8 29.7 11.3 16.4 18.0 12.3 1150 ## 5 VT01 28.5 39.4 16.0 26.0 28.8 24.0 1175 ## 6 VT01 31.6 44.2 17.2 28.5 31.8 24.4 1025 ## 7 VT01 26.9 33.5 13.8 21.3 23.4 17.7 1150 ## 8 VT01 29.3 39.8 17.3 27.0 29.6 23.4 975 ## 9 IPB22 26.9 26.4 14.5 23.7 25.9 15.7 925 ## 10 IPB22 28.7 29.8 12.9 22.6 25.6 14.8 1075 ## # ℹ 70,906 more rows Primeiro vamos fazer um histograma para poder ver a distribuição da variável imatcc. ggplot(data = tab_ifc, aes(x = imatcc)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick ## better value with `binwidth`. Agora, vamos ver a relação entre o dap e o altura dos filmes. ggplot(data = tab_ifc, aes(x = dap, y = altura)) + geom_point() ggplot(data = tab_ifc, aes(x = dap, y = altura)) + geom_point() + geom_smooth() ## `geom_smooth()` using method = &#39;gam&#39; ## and formula = &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; Qual o lucro médio dos filmes? Nosso objetivo agora é calcular o lucro médio dos filmes. Primeiro vamos criar uma coluna e calcular o lucro de cada filme. tab_ifc_modificado &lt;- mutate(tab_ifc, vol_individual = pi * dap^2 * 1/4000 * altura * 0.5) tab_ifc_modificado ## # A tibble: 70,916 × 9 ## matgen indice_sitio imatcc dap altura altura_dom area_basal ncovas_viva ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ARA6084 25.3 17.5 10.7 12.8 13.8 8.45 900 ## 2 ARA6084 24.8 13.7 9.99 12.1 13.2 6.98 850 ## 3 VT01 28.2 29.5 11.7 17.0 18.6 11.9 1100 ## 4 VT01 27.8 29.7 11.3 16.4 18.0 12.3 1150 ## 5 VT01 28.5 39.4 16.0 26.0 28.8 24.0 1175 ## 6 VT01 31.6 44.2 17.2 28.5 31.8 24.4 1025 ## 7 VT01 26.9 33.5 13.8 21.3 23.4 17.7 1150 ## 8 VT01 29.3 39.8 17.3 27.0 29.6 23.4 975 ## 9 IPB22 26.9 26.4 14.5 23.7 25.9 15.7 925 ## 10 IPB22 28.7 29.8 12.9 22.6 25.6 14.8 1075 ## # ℹ 70,906 more rows ## # ℹ 1 more variable: vol_individual &lt;dbl&gt; Vamos isolar os valores de lucro e colocar em um objeto e em seguida calcular a média. vec_vol_individual &lt;- pull(tab_ifc_modificado, vol_individual) mean(vec_vol_individual) ## [1] 1.874253 Vamos refazer os 2 primeiros passos unindo os comandos em um só. vec_vol_individual &lt;- pull(mutate(tab_ifc, vol_individual = pi * dap^2 * 1/4000 * altura * 0.5)) mean(vec_vol_individual) ## [1] 1.874253 Seguindo a mesma ideia, podemos unificar todos os comandos em uma única chamada. mean(pull(mutate(tab_ifc, vol_individual = pi * dap^2 * 1/4000 * altura * 0.5), vol_individual)) ## [1] 1.874253 Agora utilizando um operador especial chamado pipe, vamos executar as mesmas funções, porém de forma organizada e de fácil interpretação. tab_ifc %&gt;% mutate(vol_individual = pi * dap^2 * 1/4000 * altura * 0.5) %&gt;% pull(vol_individual) %&gt;% mean() ## [1] 1.874253 Sobre o Tidyverse Neste curso utilizaremos como referência os pacotes vinculados ao tidyverse, grupo de funções que utilizam a mesma filosofia de programação e foram desenvolvidos para atuarem em conjunto. O tidyverse é mantido por um time de desenvolvedores do RStudio e liderado pelo seu idealizador Hadley Wickham. Há diversas funções disponíveis nos pacotes do tidyverse que tem um equivalente direto nos pacotes base do R, mas com uma implementação mais moderna e consistente que facilita a estruturação do código. No decorrer do curso vamos ter vários exemplos desse comparativo. A manipulação de dados é, na maioria das vezes, realizado com data.frames e por isso iremos ver as principais funções que lidam com essa estrutura de forma rápida e prática. O pacote dplyr é hoje um dos pacotes mais utilizados para esta finalidade. Ele disponibiliza diversas funções que são “equivalentes” às funções básicas do R, mas como melhorias que nos poupam tempo e deixam o código muito mais fácil de interpretar. Como exemplo, vamos realizar uma análise exploratória dos dados de um inventário na floresta amazônica. library(tidyverse) library(readxl) tab_clima &lt;- read_excel(&quot;input/jpf_clima.xlsx&quot;) tab_clima ## # A tibble: 3,648 × 11 ## chave site ano mes seq nd doy lon lat tmed ppt ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ribas 2005 ribas 2005 1 1 31 15 -53.8 -20.5 25.2 325. ## 2 ribas 2005 ribas 2005 2 2 28 46 -53.8 -20.5 25.6 83.3 ## 3 ribas 2005 ribas 2005 3 3 31 74 -53.8 -20.5 25.7 117. ## 4 ribas 2005 ribas 2005 4 4 30 105 -53.8 -20.5 24.7 84.3 ## 5 ribas 2005 ribas 2005 5 5 31 135 -53.8 -20.5 21.1 104. ## 6 ribas 2005 ribas 2005 6 6 30 166 -53.8 -20.5 20.1 114. ## 7 ribas 2005 ribas 2005 7 7 31 196 -53.8 -20.5 17.4 21.8 ## 8 ribas 2005 ribas 2005 8 8 31 227 -53.8 -20.5 21.8 10.7 ## 9 ribas 2005 ribas 2005 9 9 30 258 -53.8 -20.5 22.0 133. ## 10 ribas 2005 ribas 2005 10 10 31 288 -53.8 -20.5 25.4 166. ## # ℹ 3,638 more rows Filter Com a função filter() é possível selecionar linhas específicas, de acordo com o fator que se deseja. Podem ser usados um ou vários fatores de seleção. filter(tab_clima, tmed &gt; 32) ## # A tibble: 8 × 11 ## chave site ano mes seq nd doy lon lat tmed ppt ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ribas 2023 ribas 2023 12 228 31 349 -53.8 -20.5 32.0 30.4 ## 2 tres_lagoas 2023 tres_… 2023 12 228 31 349 -51.7 -20.8 32.9 13.2 ## 3 estreito 2005 estre… 2005 10 10 31 288 -47.5 -6.58 32.3 22.4 ## 4 estreito 2015 estre… 2015 9 129 30 258 -47.5 -6.58 32.9 2.72 ## 5 estreito 2015 estre… 2015 10 130 31 288 -47.5 -6.58 32.9 43.9 ## 6 estreito 2017 estre… 2017 10 154 31 288 -47.5 -6.58 32.6 68.5 ## 7 estreito 2019 estre… 2019 9 177 30 258 -47.5 -6.58 32.7 4.85 ## 8 estreito 2020 estre… 2020 9 189 30 259 -47.5 -6.58 32.6 6.12 filter(tab_clima, tmed &gt; 32 &amp; ppt &lt; 10) ## # A tibble: 3 × 11 ## chave site ano mes seq nd doy lon lat tmed ppt ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 estreito 2015 estreito 2015 9 129 30 258 -47.5 -6.58 32.9 2.72 ## 2 estreito 2019 estreito 2019 9 177 30 258 -47.5 -6.58 32.7 4.85 ## 3 estreito 2020 estreito 2020 9 189 30 259 -47.5 -6.58 32.6 6.12 filter(tab_clima, tmed &gt; 32 | ppt &gt; 400) ## # A tibble: 28 × 11 ## chave site ano mes seq nd doy lon lat tmed ppt ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ribas 2023 ribas 2023 12 228 31 349 -53.8 -20.5 32.0 30.4 ## 2 tres_lagoas 20… tres… 2007 1 25 31 15 -51.7 -20.8 25.9 412. ## 3 tres_lagoas 20… tres… 2023 12 228 31 349 -51.7 -20.8 32.9 13.2 ## 4 acailandia 2008 acai… 2008 3 39 31 75 -47.5 -4.98 24.3 444. ## 5 acailandia 2023 acai… 2023 11 227 30 319 -47.5 -4.98 27.7 536. ## 6 estreito 2005 estr… 2005 10 10 31 288 -47.5 -6.58 32.3 22.4 ## 7 estreito 2015 estr… 2015 9 129 30 258 -47.5 -6.58 32.9 2.72 ## 8 estreito 2015 estr… 2015 10 130 31 288 -47.5 -6.58 32.9 43.9 ## 9 estreito 2017 estr… 2017 10 154 31 288 -47.5 -6.58 32.6 68.5 ## 10 estreito 2019 estr… 2019 9 177 30 258 -47.5 -6.58 32.7 4.85 ## # ℹ 18 more rows filter(tab_clima, site == &quot;ribas&quot;) ## # A tibble: 228 × 11 ## chave site ano mes seq nd doy lon lat tmed ppt ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ribas 2005 ribas 2005 1 1 31 15 -53.8 -20.5 25.2 325. ## 2 ribas 2005 ribas 2005 2 2 28 46 -53.8 -20.5 25.6 83.3 ## 3 ribas 2005 ribas 2005 3 3 31 74 -53.8 -20.5 25.7 117. ## 4 ribas 2005 ribas 2005 4 4 30 105 -53.8 -20.5 24.7 84.3 ## 5 ribas 2005 ribas 2005 5 5 31 135 -53.8 -20.5 21.1 104. ## 6 ribas 2005 ribas 2005 6 6 30 166 -53.8 -20.5 20.1 114. ## 7 ribas 2005 ribas 2005 7 7 31 196 -53.8 -20.5 17.4 21.8 ## 8 ribas 2005 ribas 2005 8 8 31 227 -53.8 -20.5 21.8 10.7 ## 9 ribas 2005 ribas 2005 9 9 30 258 -53.8 -20.5 22.0 133. ## 10 ribas 2005 ribas 2005 10 10 31 288 -53.8 -20.5 25.4 166. ## # ℹ 218 more rows filter(tab_clima, site %in% c(&quot;ribas&quot;, &quot;tres_lagoas&quot;)) ## # A tibble: 456 × 11 ## chave site ano mes seq nd doy lon lat tmed ppt ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ribas 2005 ribas 2005 1 1 31 15 -53.8 -20.5 25.2 325. ## 2 ribas 2005 ribas 2005 2 2 28 46 -53.8 -20.5 25.6 83.3 ## 3 ribas 2005 ribas 2005 3 3 31 74 -53.8 -20.5 25.7 117. ## 4 ribas 2005 ribas 2005 4 4 30 105 -53.8 -20.5 24.7 84.3 ## 5 ribas 2005 ribas 2005 5 5 31 135 -53.8 -20.5 21.1 104. ## 6 ribas 2005 ribas 2005 6 6 30 166 -53.8 -20.5 20.1 114. ## 7 ribas 2005 ribas 2005 7 7 31 196 -53.8 -20.5 17.4 21.8 ## 8 ribas 2005 ribas 2005 8 8 31 227 -53.8 -20.5 21.8 10.7 ## 9 ribas 2005 ribas 2005 9 9 30 258 -53.8 -20.5 22.0 133. ## 10 ribas 2005 ribas 2005 10 10 31 288 -53.8 -20.5 25.4 166. ## # ℹ 446 more rows Arrange Para ordenar as colunas, podemos usar a função arrange(). A hierarquia é dada pela sequência dos fatores que são adicionados como argumentos da função. arrange(tab_clima, tmed) ## # A tibble: 3,648 × 11 ## chave site ano mes seq nd doy lon lat tmed ppt ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 itarare 2016 itar… 2016 6 138 30 167 -49.3 -24.1 13.4 97.2 ## 2 itarare 2009 itar… 2009 6 54 30 166 -49.3 -24.1 13.7 84.6 ## 3 itarare 2011 itar… 2011 6 78 30 166 -49.3 -24.1 13.7 93.1 ## 4 itarare 2021 itar… 2021 7 199 31 196 -49.3 -24.1 13.8 37.8 ## 5 itarare 2007 itar… 2007 7 31 31 196 -49.3 -24.1 13.9 194. ## 6 sao_jose_campos … sao_… 2009 6 54 30 166 -45.9 -23.2 14.1 47.7 ## 7 itapetininga 2009 itap… 2009 6 54 30 166 -48.0 -23.6 14.2 70.8 ## 8 avare 2009 avare 2009 6 54 30 166 -48.9 -23.1 14.3 71.7 ## 9 itapetininga 2016 itap… 2016 6 138 30 167 -48.0 -23.6 14.3 120. ## 10 avare 2011 avare 2011 6 78 30 166 -48.9 -23.1 14.4 36 ## # ℹ 3,638 more rows arrange(tab_clima, -tmed) ## # A tibble: 3,648 × 11 ## chave site ano mes seq nd doy lon lat tmed ppt ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 estreito 2015 estr… 2015 9 129 30 258 -47.5 -6.58 32.9 2.72 ## 2 tres_lagoas 2023 tres… 2023 12 228 31 349 -51.7 -20.8 32.9 13.2 ## 3 estreito 2015 estr… 2015 10 130 31 288 -47.5 -6.58 32.9 43.9 ## 4 estreito 2019 estr… 2019 9 177 30 258 -47.5 -6.58 32.7 4.85 ## 5 estreito 2020 estr… 2020 9 189 30 259 -47.5 -6.58 32.6 6.12 ## 6 estreito 2017 estr… 2017 10 154 31 288 -47.5 -6.58 32.6 68.5 ## 7 estreito 2005 estr… 2005 10 10 31 288 -47.5 -6.58 32.3 22.4 ## 8 ribas 2023 ribas 2023 12 228 31 349 -53.8 -20.5 32.0 30.4 ## 9 acailandia 2015 acai… 2015 10 130 31 288 -47.5 -4.98 31.9 28.7 ## 10 paragominas 2015 para… 2015 10 130 31 288 -47.4 -3.03 31.9 17.7 ## # ℹ 3,638 more rows Select A função select() auxilia-nos na seleção de variáveis (colunas). select(tab_clima, site, ano, mes, ppt) ## # A tibble: 3,648 × 4 ## site ano mes ppt ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ribas 2005 1 325. ## 2 ribas 2005 2 83.3 ## 3 ribas 2005 3 117. ## 4 ribas 2005 4 84.3 ## 5 ribas 2005 5 104. ## 6 ribas 2005 6 114. ## 7 ribas 2005 7 21.8 ## 8 ribas 2005 8 10.7 ## 9 ribas 2005 9 133. ## 10 ribas 2005 10 166. ## # ℹ 3,638 more rows select(tab_clima, site:doy) ## # A tibble: 3,648 × 6 ## site ano mes seq nd doy ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ribas 2005 1 1 31 15 ## 2 ribas 2005 2 2 28 46 ## 3 ribas 2005 3 3 31 74 ## 4 ribas 2005 4 4 30 105 ## 5 ribas 2005 5 5 31 135 ## 6 ribas 2005 6 6 30 166 ## 7 ribas 2005 7 7 31 196 ## 8 ribas 2005 8 8 31 227 ## 9 ribas 2005 9 9 30 258 ## 10 ribas 2005 10 10 31 288 ## # ℹ 3,638 more rows select(tab_clima, -(seq:lat)) ## # A tibble: 3,648 × 6 ## chave site ano mes tmed ppt ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ribas 2005 ribas 2005 1 25.2 325. ## 2 ribas 2005 ribas 2005 2 25.6 83.3 ## 3 ribas 2005 ribas 2005 3 25.7 117. ## 4 ribas 2005 ribas 2005 4 24.7 84.3 ## 5 ribas 2005 ribas 2005 5 21.1 104. ## 6 ribas 2005 ribas 2005 6 20.1 114. ## 7 ribas 2005 ribas 2005 7 17.4 21.8 ## 8 ribas 2005 ribas 2005 8 21.8 10.7 ## 9 ribas 2005 ribas 2005 9 22.0 133. ## 10 ribas 2005 ribas 2005 10 25.4 166. ## # ℹ 3,638 more rows Mutate Para criar novas variáveis, podemos usar a função mutate(). Um diferencial dessa função em relação à função base do R, é que podemos utilizar variáveis criadas dentro do próprio comando. mutate( tab_clima, temp_otima = tmed &gt;= 18 &amp; tmed &lt;= 22 ) ## # A tibble: 3,648 × 12 ## chave site ano mes seq nd doy lon lat tmed ppt temp_otima ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 ribas… ribas 2005 1 1 31 15 -53.8 -20.5 25.2 325. FALSE ## 2 ribas… ribas 2005 2 2 28 46 -53.8 -20.5 25.6 83.3 FALSE ## 3 ribas… ribas 2005 3 3 31 74 -53.8 -20.5 25.7 117. FALSE ## 4 ribas… ribas 2005 4 4 30 105 -53.8 -20.5 24.7 84.3 FALSE ## 5 ribas… ribas 2005 5 5 31 135 -53.8 -20.5 21.1 104. TRUE ## 6 ribas… ribas 2005 6 6 30 166 -53.8 -20.5 20.1 114. TRUE ## 7 ribas… ribas 2005 7 7 31 196 -53.8 -20.5 17.4 21.8 FALSE ## 8 ribas… ribas 2005 8 8 31 227 -53.8 -20.5 21.8 10.7 TRUE ## 9 ribas… ribas 2005 9 9 30 258 -53.8 -20.5 22.0 133. TRUE ## 10 ribas… ribas 2005 10 10 31 288 -53.8 -20.5 25.4 166. FALSE ## # ℹ 3,638 more rows Note que se quisermos utilizar os dados calculados no futuro, temos de salvar em um objeto. No caso, vamos salvar no mesmo objeto tab_clima2 de forma que ele será atualizado com as novas colunas. tab_clima_modificado &lt;- mutate( tab_clima, temp_otima = tmed &gt;= 18 &amp; tmed &lt;= 22 ) Summarise A função summarise nos permite resumir dados. Também é possível resumir dados em função de vários fatores com o group_by. summarise(tab_clima, tmed_media = mean(tmed)) ## # A tibble: 1 × 1 ## tmed_media ## &lt;dbl&gt; ## 1 23.7 summarise(tab_clima, ppt_media = mean(ppt)) ## # A tibble: 1 × 1 ## ppt_media ## &lt;dbl&gt; ## 1 102. tab_clima_agrupado_ano &lt;- group_by(tab_clima, ano) summarise(tab_clima_agrupado_ano, tmed_media = mean(tmed)) ## # A tibble: 19 × 2 ## ano tmed_media ## &lt;dbl&gt; &lt;dbl&gt; ## 1 2005 23.6 ## 2 2006 23.0 ## 3 2007 23.5 ## 4 2008 23.2 ## 5 2009 23.4 ## 6 2010 23.4 ## 7 2011 22.9 ## 8 2012 23.6 ## 9 2013 23.5 ## 10 2014 24.0 ## 11 2015 24.7 ## 12 2016 24.0 ## 13 2017 23.6 ## 14 2018 23.7 ## 15 2019 24.5 ## 16 2020 24.2 ## 17 2021 24.1 ## 18 2022 23.5 ## 19 2023 24.4 tab_clima_agrupado_site_ano &lt;- group_by(tab_clima, site, ano) tab_clima_site_ano &lt;- summarise( tab_clima_agrupado_site_ano, tmed_anual = mean(tmed), ppt_anual = sum(ppt) ) ## `summarise()` has grouped output by ## &#39;site&#39;. You can override using the ## `.groups` argument. tab_clima_site_ano ## # A tibble: 304 × 4 ## # Groups: site [16] ## site ano tmed_anual ppt_anual ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 acailandia 2005 27.3 1136. ## 2 acailandia 2006 25.2 1930. ## 3 acailandia 2007 27.1 937. ## 4 acailandia 2008 25.6 1842. ## 5 acailandia 2009 25.4 1782. ## 6 acailandia 2010 26.5 1557. ## 7 acailandia 2011 25.4 1655. ## 8 acailandia 2012 26.5 1259. ## 9 acailandia 2013 26.2 1417. ## 10 acailandia 2014 27.0 993. ## # ℹ 294 more rows filter(tab_clima_site_ano, ppt_anual &lt; 700) ## # A tibble: 11 × 4 ## # Groups: site [9] ## site ano tmed_anual ppt_anual ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 acailandia 2015 28.4 691. ## 2 araraquara 2021 23.1 690. ## 3 caravelas 2015 25.6 667. ## 4 nanuque 2015 25.6 601. ## 5 nanuque 2023 25.4 699. ## 6 nova_venecia 2015 25.4 566. ## 7 paragominas 2015 28.8 689. ## 8 sao_mateus 2015 25.6 683. ## 9 teixeira_freitas 2015 25.5 654. ## 10 tres_lagoas 2020 26.2 641. ## 11 tres_lagoas 2021 26.2 570. Operador %&gt;% O pacote dplyr foi desenhado para trabalhar em conjunto que o operador em cadeia %&gt;%. O que esse operador faz é aplicar o que está no LHS no primeiro parâmetro da função do RHS. Podemos também direcionar o local onde o conteúdo do LHS será aplicado informando um . como argumento. tab_clima %&gt;% group_by(site, ano) %&gt;% summarise( tmed_anual = mean(tmed), ppt_anual = sum(ppt) ) %&gt;% filter(ppt_anual &lt; 700) ## `summarise()` has grouped output by ## &#39;site&#39;. You can override using the ## `.groups` argument. ## # A tibble: 11 × 4 ## # Groups: site [9] ## site ano tmed_anual ppt_anual ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 acailandia 2015 28.4 691. ## 2 araraquara 2021 23.1 690. ## 3 caravelas 2015 25.6 667. ## 4 nanuque 2015 25.6 601. ## 5 nanuque 2023 25.4 699. ## 6 nova_venecia 2015 25.4 566. ## 7 paragominas 2015 28.8 689. ## 8 sao_mateus 2015 25.6 683. ## 9 teixeira_freitas 2015 25.5 654. ## 10 tres_lagoas 2020 26.2 641. ## 11 tres_lagoas 2021 26.2 570. tab_clima %&gt;% filter(site == &quot;ribas&quot;, mes == 1) %&gt;% select(site, ano, mes, tmed) %&gt;% arrange(desc(tmed)) %&gt;% slice(1:5) ## # A tibble: 5 × 4 ## site ano mes tmed ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ribas 2013 1 27.7 ## 2 ribas 2019 1 27.0 ## 3 ribas 2020 1 26.8 ## 4 ribas 2021 1 26.5 ## 5 ribas 2015 1 26.2 Gráficos rápidos tab_clima %&gt;% group_by(site, mes) %&gt;% summarise( tmed_mensal = mean(tmed) ) %&gt;% ggplot(aes(mes,tmed_mensal, color = site)) + geom_line() + scale_x_continuous(breaks = 1:12) + theme_bw() ## `summarise()` has grouped output by ## &#39;site&#39;. You can override using the ## `.groups` argument. tab_clima %&gt;% group_by(site, ano) %&gt;% summarise(ppt_anual = sum(ppt)) %&gt;% ungroup() %&gt;% mutate(site = fct_reorder(site, ppt_anual)) %&gt;% ggplot(aes(ano, site, fill = ppt_anual)) + geom_tile() + scale_fill_viridis_b() + theme_bw() ## `summarise()` has grouped output by ## &#39;site&#39;. You can override using the ## `.groups` argument. tab_ifc %&gt;% group_by(matgen) %&gt;% summarise(imatcc = mean(imatcc)) %&gt;% top_n(10, imatcc) %&gt;% mutate(matgen = fct_reorder(matgen, -imatcc)) %&gt;% ggplot(aes(matgen, imatcc)) + geom_col() + theme_bw() tab_ifc %&gt;% ggplot(aes(area_basal, altura_dom)) + geom_point(alpha = 0.03) + geom_smooth(method = &quot;lm&quot;) + theme_bw() ## `geom_smooth()` using formula = &#39;y ~ ## x&#39; "],["joins.html", "Joins", " Joins Estamos juntando dados de tabelas o tempo todo. Por diversos motivos parte das informações estão em uma tabela e parte estão em outra e precisamos parear esses dados para seguir com a análise. No Excel essa movimentação é feita pela função PROCV(), só que de maneira mais limitada. O pacote dplyr fornece uma família de funções para trabalhar com ‘joins’ no R. Vamos ver como as principais funcionam e como podemos aplicar nas nossas análises. Primeiro, temos que ter claro que iremos fazer a operação com duas tabelas e deixar claro quem é a tabela 1 (esquerda) e a tabela 2 (direita). A tabela 1 normalmente é nossa referencia e a partir dela iremos buscar algumas ou todas informações da tabela 2 a partir de pontos em comum. Veja no esquema abaixo as 4 principais que envolvem ‘joins’. library(tidyverse) set.seed(12345) x &lt;- tibble( chave = LETTERS[c(1:3, 5)], valor1 = sample(1:10, 4) ) y &lt;- tibble( chave = LETTERS[c(1:4)], valor2 = sample(1:10, 4), valor3 = sample(20:30, 4) ) Com base na tabela x, traga os valores da tabela y que correspondam com as chaves que existem na tabela x. Notem que a tabela 1 é o objeto x e eu quero ele como referencia. left_join(x, y, by = &quot;chave&quot;) ## # A tibble: 4 × 4 ## chave valor1 valor2 valor3 ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 A 3 8 25 ## 2 B 8 2 26 ## 3 C 2 6 20 ## 4 E 5 NA NA Mas se eu quiser utilizar a tabela do objeto y como referência, ou eu mudo os objetos de posição na função ou utilizo a função right_join. right_join(x, y, by = &quot;chave&quot;) ## # A tibble: 4 × 4 ## chave valor1 valor2 valor3 ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 A 3 8 25 ## 2 B 8 2 26 ## 3 C 2 6 20 ## 4 D NA 3 27 Agora, considerando apenas o que tem em comum nas duas tabelas e depois o juntando todas as possibilidades. inner_join(x, y) ## Joining with `by = join_by(chave)` ## # A tibble: 3 × 4 ## chave valor1 valor2 valor3 ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 A 3 8 25 ## 2 B 8 2 26 ## 3 C 2 6 20 full_join(x, y) ## Joining with `by = join_by(chave)` ## # A tibble: 5 × 4 ## chave valor1 valor2 valor3 ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 A 3 8 25 ## 2 B 8 2 26 ## 3 C 2 6 20 ## 4 E 5 NA NA ## 5 D NA 3 27 Vimos até agora os ‘joins’ que movimentam colunas de uma tabela para outra, mas há os ‘joins’ que servem para filtrar linhas na tabela de referencia e não movimentam informações entre as tabelas. O semi_join mantém os registros com base na coluna chave que existem nas duas tabelas. Já o anti_join mantém o registro que existe na tabela 1, mas não na tabela 2. semi_join(x, y) ## Joining with `by = join_by(chave)` ## # A tibble: 3 × 2 ## chave valor1 ## &lt;chr&gt; &lt;int&gt; ## 1 A 3 ## 2 B 8 ## 3 C 2 anti_join(x, y) ## Joining with `by = join_by(chave)` ## # A tibble: 1 × 2 ## chave valor1 ## &lt;chr&gt; &lt;int&gt; ## 1 E 5 "],["visualização.html", "Visualização Conceitos básicos Layers Os dados A camada de geometria A camada de estatísticas Edições de eixos Aesthetics Grupos Geometrias Escalas scale_x|y_continuous Escalas de cor Facets", " Visualização O ggplot2é o pacote mais utilizado para criação de gráficos no R. Ele implementa a Gramática dos Gráficos proposta por Leland Wilkinson em seu livro The Grammar of Graphics. A ideia é que há uma gramática racional e computacional para a composição de gráficos estatísticos. Ao controlar a gramática, você pode gerar um grande conjunto de gráficos cuidadosamente construídos a partir de um conjunto relativamente pequeno de operações. Existem muitos materiais e cursos sobre como criar gráficos com o ggplot2. Basta um simples google sobre o assunto ou problema que você tem e rapidamente vai aparecer uma pergunta semelhante e várias respostas assunto. Como padrão, a documentação do pacote pode ser consultada, bem como diversos livros sobre o assunto. Recomendo o site do pacotes ggplot2 e o livro do autor Conceitos básicos Existem alguns conceitos básicos em torno desde universo de gráficos. Em primeiro lugar, os gráficos são construídos em camadas (layers). Cada componente do gráfico, a partir dos dados fornecidos, está amarrado ao sistema de coordenadas e este por sua vez, está condicionado aos resumos estatísticos, rótulos e escalas. Portanto, gráficos expressos são construídos com poucos comandos, mas com definições padrões. Para criar gráficos personalizados e de maior qualidade é preciso adicionar algumas funções… mas fique tranquilo, dificilmente vai passar de 7 camadas. As propriedades gráficas que codificam os dados são dimensões tratadas como aesthetic no ggplot2, destacando: x y size shape color fill Os elementos gráficos são as geometrias, como: point line segment bar/col text area hitogram density Você também vai querer adicionar estatísticas que resumem seus dados, e o pacote possibilita algumas delas: smooth mean/median function As dimensões (aesthetic), geometrias e resumos estatísticos constituem as mais importantes camadas de gráfico, mas há uma série de outras características que você vai querer ajustar. As mais comuns são: Eixo x ou y em escala logarítmica Paletas de cores personalizadas Formas de pontos personalizado, ou tipos de linha As seções seguintes são dedicadas a alguns destes elementos básicos ggplot2. Layers Iremos criar gráficos em camadas. A estratificação de elementos é talvez o aspecto mais poderoso do ggplot2. Isso significa que gráficos relativamente complexos são construídos com pequenas peças, que você pode adicionar ou remover de forma iterativa. Os dados O primeiro argumento da função ggplot() é um data.frame, e seu segundo argumento é aes(). Você nunca vai usar aes() em qualquer outro contexto, exceto dentro de outras funções do ggplot2, por isso talvez seja melhor não pensar em aes() como função individual, mas sim como uma forma especial de definir as dimensões dos gráficos. library(tidyverse) library(readxl) tab_inv &lt;- read_excel(&quot;input/TC5005_2017.xlsx&quot;) ggplot(tab_inv, aes(x = dap, y = h)) Veja que os dados e as dimensões dos dados já foram informados, entretanto não nada no gráfico criado por não temos uma geometria definida. Cada layer tem uma base de dados. Você pode indicar os dados na função principal ggplot() ou nos layers específicos. O mesmo ocorre para a definição das dimensões com a função aes(). A camada de geometria O passo seguinte, depois de definir os dados e as dimensões, é adicionar a geometrias. Iremos discutir geometrias em mais detalhe abaixo, mas por agora, vamos adicionar a mais simples de todas: os pontos. ggplot(tab_inv, aes(x = dap, y = h)) + geom_point() ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). Cada camada é feita por uma função. Algumas não precisarão de argumentos pois será utilizado o default. No exemplo anterior, fizemos um gráfico e adicionamos a camada de ponto geom_point(), por padrão, serão mostrados pontos pretos e sólidos de tamanho 1. Caso você queira alterar o formato do ponto, basta especificar no argumento indicado. ggplot(tab_inv, aes(x = dap, y = h)) + geom_point(shape = 2) ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). Ou, se quiséssemos usar pontos vermelhos e maiores, poderíamos definir: ggplot(tab_inv, aes(x = dap, y = h)) + geom_point(color = &quot;red&quot;, size = 3) ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). Como padrão, o ggplot2 cria um fundo cinza e linhas de grades brancas. Tem uma explicação plausível para isso e na maioria das vezes é bem útil, mas de forma geral não estamos acostumados a esse tema e isso pode incomodar. Mas fique tranquilo, isso é perfeitamente ajustável, vamos ver a seguir como fazê-lo. Outro padrão é o nome dos eixos. Ele é correspondente à variável indicada, mas também pode ser alterado utilizando a função labs. Finalmente, note que nós não precisamos dizer em geom_point() quais são as dimensões do gráfico. Já fizemos isso na função principal. Os layer herdam essas definições da função principal e por isso não precisamos ficar redefinindo a todo momento. A camada de estatísticas Adicionar uma linha de tendência uma suavização é muito simples, veja o exemplo. ggplot(tab_inv, aes(x = dap, y = h)) + geom_smooth(method = &quot;lm&quot;) ## `geom_smooth()` using formula = &#39;y ~ ## x&#39; ## Warning: Removed 1783 rows containing ## non-finite values (`stat_smooth()`). Nesse gráfico, foi ajustado uma regressão linear com um intervalo de confiança de 95%. Uma coisa importante a entender é que não é necessário incluir os pontos, podemos apresentar somente a linha de tendência. ggplot(tab_inv, aes(x = dap, y = h)) + geom_smooth(method = &quot;lm&quot;) + geom_point() ## `geom_smooth()` using formula = &#39;y ~ ## x&#39; ## Warning: Removed 1783 rows containing ## non-finite values (`stat_smooth()`). ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). Edições de eixos Podemos alterar o nome dos eixos e ainda adicionar título, subtítulo e fonte ao gráfico. ggplot(tab_inv, aes(x = dap, y = h)) + geom_point(alpha = 0.5) + labs( title = &quot;Experimento TC5005&quot;, subtitle = &quot;Fazenda Penha&quot;, caption = &quot;Suzano SA&quot;, x = &quot;CAP (cm)&quot;, y = &quot;Altura (m)&quot; ) + theme_bw() ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). Aesthetics No ggplot2, aesthetic são os elementos gráficos que representam as dimensões dos dados, e que são definidos com aes(). Em certa medida, a dimensão que você precisa para definir depende das geometrias que você deseja utilizar. Por exemplo, segmentos de linha tem propriedades geométricas diferentes de pontos. Mas de maneira geral, essa padronização não é problemática. x: localização do eixo-X. y: localização do eixo y. color: A cor das linhas, pontos, e as fronteiras externas das geometrias (polígonos, barras, etc.). fill : A cor de preenchimento das geometrias. size: O tamanho dos pontos. shape: Específico para pontos, define a forma dele. linetype: Específico para linhas, define o tipo de linha, caminho, ou borda de uma geometria. alpha: Isto define a opacidade de qualquer propriedade geométrica. É mais utilizada quando temos sobreposição de pontos ou linhas e queremos enxergar o que está por de trás. xend, yend: Você vai usá-los raramente, quando criar um segmento de linha, ou seta. O início do segmento de linha será localizado o x e y, e a extremidade do segmento de linha será definida em xend, yend. Se aplicarmos a dimensão de cor em função da variável Cod, vamos notar que o ggplot2 entendeu que se trata de números e por isso adicionou uma escala contínua de cor na legenda. Não está certo, mas é o default. ggplot(tab_inv, aes(x = dap, y = h, color = cod1)) + geom_point() ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). O ggplot2 gerou automaticamente uma paleta de cores para os dados e criou uma legenda. Tal como acontece com tudo, a paleta de cores também é ajustável, o que será discutido em mais detalhe abaixo. O padrão de cores do ggplot2 é bastante inteligente. Cada cor é equidistante em torno de um círculo de cor HSL, e têm igual luminância. A ideia é que nenhuma categoria tenha maior destaque que outra, em contrapartida ela pode ser um problema para leitores daltônicos. ggplot(tab_inv, aes(x = dap, y = h)) + geom_point(color = &quot;red&quot;) ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). Neste momento você pode notar a diferença de indicar a cor fora do aes() não gera legenda e se aplica a todos os pontos. Quando a cor representa uma dimensão dos nossos dados, seja uma escala discreta ou contínua, ela deve ser indicada dentro da função aes() em conjunto com a variável que definirá a dimensão. Grupos Vamos criar um gráfico com uma linha de tendência por ano. O parâmetro se = FALSE é para retirar o intervalo de confiança da linha de tendência e facilita a visualização. ggplot(tab_inv, aes(x = dap, y = h, color = clone)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) ## `geom_smooth()` using formula = &#39;y ~ ## x&#39; ## Warning: Removed 1783 rows containing ## non-finite values (`stat_smooth()`). ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). Como a dimensão cor foi definida na função principal, todos layers herdaram essa informação. Mas e se quisermos um gráfico com pontos coloridos, mas só uma linha de tendência? Simples, vamos dar a dimensão de cor somente para o layer de pontos. ggplot(tab_inv, aes(x = dap, y = h)) + geom_point(aes(color = clone)) + geom_smooth(method = &quot;lm&quot;) ## `geom_smooth()` using formula = &#39;y ~ ## x&#39; ## Warning: Removed 1783 rows containing ## non-finite values (`stat_smooth()`). ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). É importante lembrar que não é só a dimensão de cor que gera sub-agrupamentos no gráfico. Se utilizarmos a forma para diferenciar a variável, essa definição também será herdade nos layers subsequentes. ggplot(tab_inv, aes(x = dap, y = h, shape = clone)) + geom_point() ## Warning: The shape palette can deal with a ## maximum of 6 discrete values because ## more than 6 becomes difficult to ## discriminate ## ℹ you have requested 7 values. ## Consider specifying shapes manually ## if you need that many have them. ## Warning: Removed 1832 rows containing missing ## values (`geom_point()`). A criação de gráficos com cores é uma atividade comum em muitas situações. Podemos definir se um gráfico será colorido de duas formas, o preenchimento interno da geometria ou a linha externa. Para o primeiro, utilizamos o argumento fill = &lt;variável&gt;e para o segundo color = &lt;variável&gt;. Note que as variáveis podem ser contínuas ou discretas para ambos os casos. tab_resumo_clone &lt;- tab_inv %&gt;% group_by(clone) %&gt;% summarise( h = mean(h, na.rm = TRUE), dap = mean(dap, na.rm = TRUE), n_arv = n(), n_falha = sum(if_else(cod1 == 1, 1, 0), na.rm = TRUE), p_falha = (n_falha / n_arv) * 100 ) ggplot(tab_resumo_clone, aes(dap, clone)) + geom_col() Se quisermos colorir as barras, o primeiro instinto seria provavelmente para definir color = Esp. Mas este argumento considera apenas o contorno das figuras bidimensionais. ggplot(tab_resumo_clone, aes(clone, dap, color = clone)) + geom_col() O preenchimento é feito utilizando o argumento fill = Esp. ggplot(tab_resumo_clone, aes(clone, dap, fill = clone)) + geom_col() Geometrias Até o momento, nós usamos as seguintes geometrias: geom_point() geom_smooth() geom_col() Todas as geometrias começam com geom_*, esta é a lista completa das geometrias disponível pelo ggplot2. apropos(&quot;^geom_&quot;) ## [1] &quot;geom_abline&quot; &quot;geom_area&quot; &quot;geom_bar&quot; ## [4] &quot;geom_bin_2d&quot; &quot;geom_bin2d&quot; &quot;geom_blank&quot; ## [7] &quot;geom_boxplot&quot; &quot;geom_col&quot; &quot;geom_contour&quot; ## [10] &quot;geom_contour_filled&quot; &quot;geom_count&quot; &quot;geom_crossbar&quot; ## [13] &quot;geom_curve&quot; &quot;geom_density&quot; &quot;geom_density_2d&quot; ## [16] &quot;geom_density_2d_filled&quot; &quot;geom_density2d&quot; &quot;geom_density2d_filled&quot; ## [19] &quot;geom_dotplot&quot; &quot;geom_errorbar&quot; &quot;geom_errorbarh&quot; ## [22] &quot;geom_freqpoly&quot; &quot;geom_function&quot; &quot;geom_hex&quot; ## [25] &quot;geom_histogram&quot; &quot;geom_hline&quot; &quot;geom_jitter&quot; ## [28] &quot;geom_label&quot; &quot;geom_line&quot; &quot;geom_linerange&quot; ## [31] &quot;geom_map&quot; &quot;geom_path&quot; &quot;geom_point&quot; ## [34] &quot;geom_pointrange&quot; &quot;geom_polygon&quot; &quot;geom_qq&quot; ## [37] &quot;geom_qq_line&quot; &quot;geom_quantile&quot; &quot;geom_raster&quot; ## [40] &quot;geom_rect&quot; &quot;geom_ribbon&quot; &quot;geom_rug&quot; ## [43] &quot;geom_segment&quot; &quot;geom_sf&quot; &quot;geom_sf_label&quot; ## [46] &quot;geom_sf_text&quot; &quot;geom_smooth&quot; &quot;geom_spoke&quot; ## [49] &quot;geom_step&quot; &quot;geom_text&quot; &quot;geom_tile&quot; ## [52] &quot;geom_violin&quot; &quot;geom_vline&quot; Esta é uma lista bastante extensa, e não iremos ver todo seu conteúdo hoje. Mas podemos iremos exemplificar alguns casos. Histograma e Densidade O histograma é um gráfico univariado bastante comum no meio científico. Sua principal função é apresentar a distribuição de frequências dos dados. ggplot(tab_inv, aes(dap)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick ## better value with `binwidth`. ## Warning: Removed 305 rows containing non-finite ## values (`stat_bin()`). Densidade Visualizar a distribuição de frequências também é um recurso muito interessante para entender os nossos dados. Podemos fazê-lo através de um histograma eu de gráfico de densidade de frequências. ggplot(tab_inv, aes(h)) + geom_density(fill = &quot;grey&quot;) ## Warning: Removed 1783 rows containing ## non-finite values (`stat_density()`). Podemos identificar a distribuição do Esp através de cores. ggplot(tab_inv, aes(h, fill = clone)) + geom_density() ## Warning: Removed 1783 rows containing ## non-finite values (`stat_density()`). Entretanto o padrão da função geom_density() é usar position = \"identity\". Isso significa que pode haver (como de fato acontece) sobreposição das curvas. Uma alternativa rápida é colocar opacidade ao preenchimento para poder ver através das curvas. ggplot(tab_inv, aes(h, fill = clone, color = clone)) + geom_density(alpha = 0.3) ## Warning: Removed 1783 rows containing ## non-finite values (`stat_density()`). Caso o interesse seja ver a contribuição de cada sexo para a distribuição total do peso, iremos trabalhar com o parâmetro position = \"stack\" ggplot(tab_inv, aes(h, fill = clone, color = clone)) + geom_density(position = &quot;stack&quot;) ## Warning: Removed 1783 rows containing ## non-finite values (`stat_density()`). A próxima variação é tratar os valores em porcentagem, do mesmo modo que fizemos com as barras. ggplot(tab_inv, aes(h, fill = clone, color = clone)) + geom_density(position = &quot;fill&quot;) ## Warning: Removed 1783 rows containing ## non-finite values (`stat_density()`). Boxplot O boxplot é um gráfico muito útil para demonstrar a distribuição dos dados. Seu objetivo é evidenciar os quartis e outliers. ggplot(tab_inv, aes(clone, h)) + geom_boxplot() ## Warning: Removed 1783 rows containing ## non-finite values (`stat_boxplot()`). Entretanto não vemos os pontos e muitas vezes o gráfico pode nos enganar pois não vemos quantos pontos cada fator tem de verdade. Como alternativa a isto, podemos plotar os pontos em conjunto. ggplot(tab_inv, aes(clone, h)) + geom_boxplot() + geom_point() ## Warning: Removed 1783 rows containing ## non-finite values (`stat_boxplot()`). ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). Entretanto, mais uma vez o gráfico pode nos enganar pois a sobreposição dos pontos esconde a verdadeira quantidade. A alternativa para esta situação é utilizar a função jitter(), que adiciona uma variação aleatória aos pontos transformando-os em uma massa de pontos. Para não haver duplicidades nos outliers, podemos retirara-los do boxplot. ggplot(tab_inv, aes(clone, h)) + geom_boxplot(outlier.color = NA) + geom_jitter( width = 0.1, alpha = 0.5 ) ## Warning: Removed 1783 rows containing ## non-finite values (`stat_boxplot()`). ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). Vilolin e dotplot Para os que não gostam ou não entendem o boxplot, uma alternativa de gráfico que expressa a mesma ideia é o violin plot. O gráfico consiste em uma curva de densidade simétrica para cada fator. ggplot(tab_inv, aes(clone, dap)) + geom_violin() ## Warning: Removed 305 rows containing non-finite ## values (`stat_ydensity()`). Podemos ainda adicionar os pontos para ter uma noção de quantidade. ggplot(tab_inv, aes(clone, dap)) + geom_violin() + geom_jitter(alpha = 0.3, width = 0.1) ## Warning: Removed 305 rows containing non-finite ## values (`stat_ydensity()`). ## Warning: Removed 305 rows containing missing ## values (`geom_point()`). Barras Para demonstrar como os diferentes tipos de agrupamento de barras funcionam, vamos criar um gráfico que possui contagem de diferentes categorias por fator. ggplot(tab_resumo_clone, aes(clone, dap)) + geom_col() Podemos adicionar a dimensão de color para verificar a diferença nos dado tab_resumo_clone %&gt;% ggplot(aes(clone, dap, fill = n_falha)) + geom_col() Texto Adição de texto e rótulos ao gráfico em forma de geometria. Caso queira inserir uma anotação, utiliza annotate(). Uma questão especial Há uma estético especial apenas para geom_text() ou geom_label() chamadas label, que define a coluna que deve ser utilizada como marcador de texto. ggplot(tab_inv, aes(dap, h, label = cod1)) + geom_point() + geom_label() + annotate(&quot;text&quot;, 15, 10, label = &quot;Este é um comentário&quot;) ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). ## Warning: Removed 1959 rows containing missing ## values (`geom_label()`). Escalas Todos os tipos de escala (eixos x e y, cor, preenchimento e tamanho) tem funções específicas de controle e podem ser totalmente customizadas. Os eixos, por exemplo, são modificados pelas funções com o prefixo scale_[x|y]_**(). apropos(&quot;^scale_x_&quot;) ## [1] &quot;scale_x_binned&quot; &quot;scale_x_continuous&quot; &quot;scale_x_date&quot; ## [4] &quot;scale_x_datetime&quot; &quot;scale_x_discrete&quot; &quot;scale_x_log10&quot; ## [7] &quot;scale_x_reverse&quot; &quot;scale_x_sqrt&quot; &quot;scale_x_time&quot; scale_x_continuous, scale_x_discrete, scale_x_datetime e scale_x_date são os tipos básicos de eixos x e y que você pode modificar no ggplot2. scale_x_log10, scale_x_sqrt e scale_x_reverse são transformações básicas para uma escala contínua. Também veremos como criar nossa nossa sequência para composição de eixos. Existem alguns argumentos básicos par as funções relacionadas às escalas numéricas. name: Nome do eixo ou título da legenda. limits: Define o intervalo que os dados serão apresentados no gráfico. breaks: Marcadores dos eixos ou da legenda. labels: Rótulos dos marcadores. scale_x|y_continuous O ggplot2 determina uma escala e limite padrão para os gráficos de acordo com a escala de variação. Às vezes, queremos maior detalhe da escala e por isso temos que modificar os argumentos. ggplot(tab_inv, aes(dap, h)) + geom_point() ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). A alteração dos breacks é feita por um vetor que indica onde será adicionado o marcador do eixo. ggplot(tab_inv, aes(dap, h)) + geom_point() + scale_x_continuous(breaks = seq(0, 90, 2)) ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). Caso seja interessante altera o rotulo do marcador, temos que criar um novo vetor que contem os nomes. ggplot(tab_inv, aes(dap, h)) + geom_point() + scale_x_continuous(breaks = seq(0, 90, 5), labels = paste(seq(0, 90, 5), &quot;cm&quot;)) ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). Escalas de cor A paleta de cor é um ponto crítico em um gráfico. Muitas vezes utilizamos a dimensão de cor para comparar algo e por este motivo devemos escolher com cuidado as cores que iremos colocar. O ggplot2 disponibiliza algumas paletas e funções à nossa disposição. Vocês podem pesquisar cada uma delas mais tarde e ver qual o diferencial que cada uma trás. apropos(&quot;^scale_color_&quot;) ## [1] &quot;scale_color_binned&quot; &quot;scale_color_brewer&quot; &quot;scale_color_continuous&quot; ## [4] &quot;scale_color_date&quot; &quot;scale_color_datetime&quot; &quot;scale_color_discrete&quot; ## [7] &quot;scale_color_distiller&quot; &quot;scale_color_fermenter&quot; &quot;scale_color_gradient&quot; ## [10] &quot;scale_color_gradient2&quot; &quot;scale_color_gradientn&quot; &quot;scale_color_grey&quot; ## [13] &quot;scale_color_hue&quot; &quot;scale_color_identity&quot; &quot;scale_color_manual&quot; ## [16] &quot;scale_color_ordinal&quot; &quot;scale_color_steps&quot; &quot;scale_color_steps2&quot; ## [19] &quot;scale_color_stepsn&quot; &quot;scale_color_viridis_b&quot; &quot;scale_color_viridis_c&quot; ## [22] &quot;scale_color_viridis_d&quot; A característica básica é que existem funções para variáveis discretas e funções para variais contínuas. Para variáveis discretas, por exemplo, a função padrão é a scale_[fill|color]_hue(). ggplot(tab_inv, aes(dap, h, color = clone)) + geom_point() + scale_fill_hue() ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). O pacote RColorBrewer disponibiliza um conjunto de paletas que podem ser incorporadas no ggplot2. basta identificar qual você deseja. Há paletas sequenciais e paletas divergentes. Caso queria ver as paletas, explore pelo comando RColorBrewer::display.brewer.all(). No gráfico, basta indicar o nome da paleta no argumento palette. ggplot(tab_inv, aes(dap, h, color = clone)) + geom_point() + scale_color_brewer(palette = &quot;Set1&quot;) ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). Caso você queria colocar suas próprias cores, terá de fazer isso manualmente. Eu recomendo o site http://colorbrewer2.org/. A partir do código hexadecimal, podemos colocar as cores que queremos com a função scale_[color|fill]_manual(). ggplot(tab_inv, aes(dap, h, color = clone)) + geom_point() + scale_color_manual(values = c(&quot;red&quot;, &quot;blue&quot;, &quot;darkgreen&quot;, &quot;gold&quot;, &quot;cyan&quot;, &quot;#fc9272&quot;, &quot;#4a1486&quot;)) ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). Se for preciso economizar na impressão e colocar o gráfico em escala de cinza, sem problema, temos uma função pronta para isto. ggplot(tab_inv, aes(dap, h, color = clone)) + geom_point() + scale_color_grey() ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). Facets Talvez o recuso mais interessante do R e ggplot2 no contexto de gráficos exploratórios seja a possibilidade (e facilidade) de criar gráficos em painéis. Esse pode ser feito em outros softwares, mas o ggplot2 oferece uma gama de funcionalidades relacionadas a este tema. ggplot(tab_inv, aes(dap, h, color = clone)) + geom_point() + geom_smooth(method = &quot;lm&quot;) + facet_wrap(~clone) + scale_color_brewer(palette = &quot;Dark2&quot;) ## `geom_smooth()` using formula = &#39;y ~ ## x&#39; ## Warning: Removed 1783 rows containing ## non-finite values (`stat_smooth()`). ## Warning: Removed 1783 rows containing missing ## values (`geom_point()`). "],["exercícios.html", "Exercícios", " Exercícios Alguns pacotes possuem data frames para uso nos exemplos. Carregue o pacote gapminder aplique a função glimpse na objeto gapminder que pertence ao respectivo pacote. ## Rows: 1,704 ## Columns: 6 ## $ country &lt;fct&gt; &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, … ## $ continent &lt;fct&gt; Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, … ## $ year &lt;int&gt; 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, … ## $ lifeExp &lt;dbl&gt; 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8… ## $ pop &lt;int&gt; 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12… ## $ gdpPercap &lt;dbl&gt; 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 786.1134, … Importe o arquivo continents.xlsx e mostre seu conteúdo na tela. ## # A tibble: 6 × 4 ## continent area_km2 population percent_total_pop ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Africa 30370000 1022234000 15 ## 2 Americas 42330000 934611000 14 ## 3 Antarctica 13720000 4490 0 ## 4 Asia 43820000 4164252000 60 ## 5 Europe 10180000 738199000 11 ## 6 Oceania 9008500 29127000 0.4 Faça um join entre a tabela gapminder e continents, onde gapminder será a tabela de referência. Salve essa operação em um objeto chamado gap_cont. ## Joining with `by = join_by(continent)` ## # A tibble: 1,704 × 9 ## country continent year lifeExp pop gdpPercap area_km2 population ## &lt;fct&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. 43820000 4164252000 ## 2 Afghanistan Asia 1957 30.3 9240934 821. 43820000 4164252000 ## 3 Afghanistan Asia 1962 32.0 10267083 853. 43820000 4164252000 ## 4 Afghanistan Asia 1967 34.0 11537966 836. 43820000 4164252000 ## 5 Afghanistan Asia 1972 36.1 13079460 740. 43820000 4164252000 ## 6 Afghanistan Asia 1977 38.4 14880372 786. 43820000 4164252000 ## 7 Afghanistan Asia 1982 39.9 12881816 978. 43820000 4164252000 ## 8 Afghanistan Asia 1987 40.8 13867957 852. 43820000 4164252000 ## 9 Afghanistan Asia 1992 41.7 16317921 649. 43820000 4164252000 ## 10 Afghanistan Asia 1997 41.8 22227415 635. 43820000 4164252000 ## # ℹ 1,694 more rows ## # ℹ 1 more variable: percent_total_pop &lt;dbl&gt; Com base no objeto gap_cont, filtre as informações do continente Oceania. ## # A tibble: 24 × 9 ## country continent year lifeExp pop gdpPercap area_km2 population ## &lt;fct&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Australia Oceania 1952 69.1 8691212 10040. 9008500 29127000 ## 2 Australia Oceania 1957 70.3 9712569 10950. 9008500 29127000 ## 3 Australia Oceania 1962 70.9 10794968 12217. 9008500 29127000 ## 4 Australia Oceania 1967 71.1 11872264 14526. 9008500 29127000 ## 5 Australia Oceania 1972 71.9 13177000 16789. 9008500 29127000 ## 6 Australia Oceania 1977 73.5 14074100 18334. 9008500 29127000 ## 7 Australia Oceania 1982 74.7 15184200 19477. 9008500 29127000 ## 8 Australia Oceania 1987 76.3 16257249 21889. 9008500 29127000 ## 9 Australia Oceania 1992 77.6 17481977 23425. 9008500 29127000 ## 10 Australia Oceania 1997 78.8 18565243 26998. 9008500 29127000 ## # ℹ 14 more rows ## # ℹ 1 more variable: percent_total_pop &lt;dbl&gt; Faça um heatmap considerando apenas os países da asia, onde no eixo x temos o year, no eixo y o country e na dimensão de preenchimento lifeExp. Dicas: filter, geom_tile. Faça um gráfico de dispersão da area do continente e a renda per capta média do continente. Lembre-se que ao computar a renda média do continente a partir dos países, precisamos ponderar pela população de cada país. A renda per capta é a variável gdpPercap. A área está na variável area_km2 do objeto continents. Faça o gráfico proposto logo abaixo. Dicas: mutate, group_by, summarize, left_join, geom_text e o parâmetro nudge_y. ## Joining with `by = join_by(continent)` "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
